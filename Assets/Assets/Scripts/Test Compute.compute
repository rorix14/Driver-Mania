#define MATRIX_GRID_THREAD_COUNT 8

#pragma kernel transpose_matrix
#pragma kernel matrix_dot_product
//#pragma kernel test

// const int test_x = 3;
// const int test_y = 2;

//shared RWTexture2D<float> source;
//shared RWTexture2D<float> sourceR;

// struct mat_
// {
//     float tt[3][3];
//     //float tt;
// };

// struct mat_T
// {
//     RWStructuredBuffer<float> tt;
// };

int column_size_1;
int row_size_1;
int column_size_2;
int row_size_2;

StructuredBuffer<float> mat_1;
StructuredBuffer<float> mat_2;
RWStructuredBuffer<float> result_mat;

// NN variables
StructuredBuffer<float> biases;

[numthreads(1,1,1)]
void transpose_matrix(uint3 id : SV_DispatchThreadID)
{
    result_mat[id.y * column_size_1 + id.x] = mat_1[id.x * row_size_1 + id.y];
}

// x = column 1
// y = row 2
// row size 1 = column size 2
[numthreads(MATRIX_GRID_THREAD_COUNT,MATRIX_GRID_THREAD_COUNT,1)]
void matrix_dot_product(uint3 id : SV_DispatchThreadID)
{
    float result = 0;
    for (int i = 0; i < row_size_1; ++i)
    {
        result += mat_1[id.x * row_size_1 + i] * mat_2[i * row_size_2 + id.y];
    }

    result += biases[id.y];
    result_mat[id.x * row_size_2 + id.y] = result <= 0 ? 0 : result;
}

// [numthreads(3,3,1)]
// void test (uint3 id : SV_DispatchThreadID)
// {
//    result_mat[0].tt[id.x][id.y] = 0;
//    result_mat[0].tt[id.x][id.y] = 0;
//    result_mat[0].tt[id.y][id.x] = mat[0].tt[id.x][id.y];
//    result_mat[0].tt[id.x][id.y] = =source[id.yx];
//    sourceR[id.xy] = mat[0].tt[id.x][id.y];
//    source[id.xy] = sourceR[id.xy];
//
//    result_mat[0].tt[id.x][id.y] = id.x + id.y;
//    result_mat[0] += mat[0].tt[id.x][id.y];
//    mat[id.x * row_size + id.y] = 8;
//    result_mat[id.x * row_size + id.y] = id.x * row_size + id.y;
//     for (int i = 0; i < testX; i++)
//     {
//         for (int j = 0; j < testY; j++)
//         {
//             transposedMat[j, i] = mat[i, j];
//         }
//     }
// }
